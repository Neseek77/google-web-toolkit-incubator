/*
 * Copyright 2008 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.gwt.gen2.selection.client;

import com.google.gwt.gen2.event.shared.HandlerRegistration;
import com.google.gwt.gen2.event.shared.SelectionEvent;
import com.google.gwt.gen2.event.shared.SelectionHandler;
import com.google.gwt.gen2.widgetbase.client.Decorator;
import com.google.gwt.gen2.widgetbase.client.Gen2Composite;
import com.google.gwt.gen2.widgetbase.client.Gen2Widget;
import com.google.gwt.libideas.resources.client.CssResource.ClassName;
import com.google.gwt.user.client.Event;
import com.google.gwt.user.client.ui.MenuItemSeparator;
import com.google.gwt.user.client.ui.MultiWordSuggestOracle;
import com.google.gwt.user.client.ui.SuggestionMenuImpl;
import com.google.gwt.user.client.ui.Widget;

import java.util.HashMap;

/**
 * A custom list box. Used as a base class for {@link DropDownListBox} and
 * (eventually) a multi-select list box. The abstract custom list box is a
 * composite to allow inherited classes to specialize the look and feel of the
 * widget.
 * 
 * <br/> Use {@link Gen2CssInfo#addDropDownListBoxDefault()} to inject the
 * default list box css when css injection is enabled, include the DebugCss
 * module (which picks up all the default css files), to debug the default css.
 * 
 * @param <ValueType> the type of the values backing this list box
 */
public abstract class CustomListBox<ValueType> extends
    Gen2Composite<Widget> implements SelectionEvent.Source<ValueType> {

  /**
   * Interface used to allow the widget access to css style names. <p/> The
   * class names indicate the default gwt names for these styles.
   */
  public static interface Css extends BaseCss {
    /**
     * Disabled item.
     */
    String disabledItem();

    /**
     * Highlighted item.
     */
    String highlightedItem();

    /**
     * Inner div of a list separator.
     */
    String innerSeparator();

    /**
     * List item.
     */
    String item();

    /**
     * List box wrapper.
     */
    String listBox();

    /**
     * Outer div of a list separator.
     */
    String outerSeparator();

    /**
     * Selected and disabled item.
     */
    @ClassName("gwt-CustomListBox-selectedAndDisabledItem")
    String selectedAndDisabledItem();

    /**
     * Selected and highlighted item.
     */
    @ClassName("gwt-CustomListBox-selectedAndHighlightedItem")
    String selectedAndHighlightedItem();

    /**
     * Selected item.
     */
    @ClassName("gwt-CustomListBox-selectedItem")
    String selectedItem();

    @ClassName("gwt-CustomListBox")
    String styleName();
  }

  /**
   * Adaptor class to allow the use of setStyleName/setPrimaryStyleName. Right
   * now these are created manually, could be generated by a generator in the
   * medium term.
   */
  protected static class CssAdaptor extends
      Gen2Widget.CssAdaptor<CustomListBox> implements CustomListBox.Css {

    /**
     * Constructor.
     */
    public CssAdaptor(String baseStyleName) {
      super(baseStyleName);
    }

    @Override
    public void assignStyleName(CustomListBox widget, String name) {
      widget.setCss(new CssAdaptor(name));
    }

    public String disabledItem() {
      return wrap("disabledItem");
    }

    public String highlightedItem() {
      return wrap("highlightedItem");
    }

    public String innerSeparator() {
      return wrap("innerSeparator");
    }

    public String item() {
      return wrap("item");
    }

    public String listBox() {
      return wrap("listBox");
    }

    public String outerSeparator() {
      return wrap("outerSeparator");
    }

    public String selectedAndDisabledItem() {
      return wrap("selectedAndDisabledItem");
    }

    public String selectedAndHighlightedItem() {
      return wrap("selectedAndHighlightedItem");
    }

    public String selectedItem() {
      return wrap("selectedItem");
    }
  }

  /**
   * Menu shared with SuggestBox for efficiency.
   */
  private class ItemMenu extends SuggestionMenuImpl {
    private class Item extends SuggestionItem {

      private ValueType value;

      public Item(String html, ValueType value, String tooltip, String summary) {

        super(new MultiWordSuggestOracle.MultiWordSuggestion(summary, html),
            true);
        this.value = value;
        if (tooltip != null) {
          this.setTitle(tooltip);
        }
      }

      public String getSummary() {
        return this.getSuggestion().getReplacementString();
      }

      public String getTooltip() {
        return getSuggestion().getReplacementString();
      }

      public ValueType getValue() {
        return value;
      }

      public boolean isHighlighted() {
        return getHighlightedItem() == this;
      }

      public boolean isSelected() {
        return this == selected;
      }

      public void updateStyle(boolean isHighlighted, boolean isSelected) {
        String style = css.item() + " ";
        if (isHighlighted && isSelected) {
          style += css().selectedAndHighlightedItem();
        } else if (isHighlighted) {
          style += css().highlightedItem();
        } else if (isSelected) {
          style += css().selectedItem();
        }
        this.getElement().setClassName(style);
      }

      @Override
      protected void updateStyle(boolean isHighlighted) {
        updateStyle(isHighlighted, isSelected());
      }
    }

    private HashMap<ValueType, Item> map = new HashMap<ValueType, Item>();

    private Item selected;

    public void addItem(String html, ValueType value, String tooltip,
        String replacement) {
      assert (html != null);
      assert (value != null);

      Item menuItem = new Item(supplyItemDecorator().wrapHTML(html), value,
          tooltip, replacement);
      menuItem.setStyleName(css().item());
      map.put(value, menuItem);
      super.addItem(menuItem);
    }

    public ValueType getHighlightedValue() {
      return getValue(getHighlightedItem());
    }

    public void onHide() {
      // TODO(ecc) once we get rid of the PopupPanelOverride hack, should be
      // able to again pass in dropdown.
      super.onPopupClosed(null, false);

      // Clear selected highlight.
      highlightItem(null);
    }

    protected ValueType getSelectedValue() {
      return getValue(selected);
    }

    @Override
    protected void onHighlight(SuggestionItem s) {
    }

    @Override
    protected void onSelection(SuggestionItem newItem) {

      ValueType oldValue = null;
      if (selected != null) {
        selected.updateStyle(selected.isHighlighted(), false);
        oldValue = selected.getValue();
      }

      selected = (Item) newItem;
      if (newItem != null) {
        selected.updateStyle(selected.isHighlighted(), true);
        currentSummary = selected.getSummary();
        if (currentSummary == null) {
          currentSummary = defaultSummary;
        }
      }

      ValueType newValue = selected == null ? null : selected.getValue();
      fireEvent(new SelectionEvent(oldValue, newValue));
    }

    protected final void select(ValueType value) {
      onSelection(getItem(value));
    }

    Item getItem(ValueType value) {
      return map.get(value);
    }

    private ValueType getValue(SuggestionItem item) {
      return (item == null ? null : ((Item) item).getValue());
    }
  }

  private Css css;

  // The fact that we are backed by an item menu is not part of the public API
  private ItemMenu itemMenu = new ItemMenu();

  /**
   * default summary for this list box.
   */
  private String defaultSummary;

  /**
   * Current summary of this list box.
   */
  private String currentSummary;

  /**
   * Creates a custom list box with the given css.
   */
  public CustomListBox(Css css) {
    this(css, "");
  }

  /**
   * Creates a custom list box with the given css and default summary describing
   * the list.
   */
  public CustomListBox(Css css, String defaultSummary) {
    setCss(css);
    this.defaultSummary = defaultSummary;
    this.currentSummary = defaultSummary;
  }

  /**
   * Adds an item to the custom list box.
   * 
   * @param html the html of the item to be displayed
   * @param value the item's value.
   */
  public final void addItem(String html, ValueType value) {
    addItem(html, value, null, null);
  }

  /**
   * Adds an item to the custom list box.
   * 
   * @param html the html of the item to be added
   * @param value the item's value.
   * @param tooltip tooltip
   */
  public final void addItem(String html, ValueType value, String tooltip) {
    itemMenu.addItem(html, value, tooltip, null);
  }

  /**
   * Adds an item to the custom list box.
   * 
   * @param html the html of the item to be added
   * @param value the item's value.
   * @param tooltip tooltip
   * @param buttonFace the button face that should be displayed when this item
   *          is selected
   */
  public final void addItem(String html, ValueType value, String tooltip,
      String buttonFace) {
    itemMenu.addItem(html, value, tooltip, buttonFace);
  }

  public final HandlerRegistration addSelectionHandler(
      SelectionHandler<ValueType> handler) {
    return super.addHandler(SelectionEvent.KEY, handler);
  }

  /**
   * Adds a list item separator.
   */
  public final void addSeparator() {
    MenuItemSeparator sep = itemMenu.addSeparator();
    sep.setStyleName(css().outerSeparator());
    sep.getElement().getFirstChildElement().setClassName(css().innerSeparator());
  }

  @Override
  public Css css() {
    return css;
  }

  /**
   * Gets the highlighted value.
   */
  public final ValueType getHighlightedValue() {
    return itemMenu.getHighlightedValue();
  }

  /**
   * Gets the number of items in the list.
   */
  public int getNumItems() {
    return itemMenu.getNumItems();
  }

  @Override
  public void onBrowserEvent(Event e) {
    itemMenu.onBrowserEvent(e);
    super.onBrowserEvent(e);
  }

  /**
   * Sets the selected value.
   * 
   * @param value the selected value
   */
  public final void setSelectedValue(ValueType value) {
    itemMenu.select(value);
  }

  /**
   * Gets the title for the most recently selected value.
   */
  protected final ValueType getLastSelectedValue() {
    return itemMenu.getSelectedValue();
  }

  /**
   * Returns the actual list box widget.
   */
  protected Widget getListBox() {
    return itemMenu;
  }

  /**
   * Gets an html summary for this list box's current state. Each item may
   * supply its own summary, and that summary will be active when the item is
   * selected.
   */
  protected String getSummary() {
    return currentSummary;
  }

  /**
   * Supply a decorator for the list items.
   * 
   * @return a decorator
   */
  protected Decorator supplyItemDecorator() {
    return Decorator.DEFAULT;
  }

  /**
   * Supply a decorator for the list box.
   * 
   * @return a decorator
   */
  protected Decorator supplyListBoxDecorator() {
    return Decorator.DEFAULT;
  }

  /**
   * Sets the css for this widget.
   */
  private void setCss(Css css) {
    this.css = css;
    itemMenu.setStylePrimaryName(css.listBox());
  }
}
