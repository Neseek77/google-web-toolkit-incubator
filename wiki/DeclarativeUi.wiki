#summary Declarative XML structure for defining GWT widgets
#labels Type-Library

_There is a more up to date set of use cases at UiBinder_

= Declarative UI Construction in GWT =

Joel Webber

= Motivation & Use Cases =
Writing imperative Java code to construct a user-interface hierarchy is awkward, and it makes working with UI designers difficult and/or impossible. What we want is to provide designers (and developers) with a simple way to define the static structure of applications and widgets, without having to write code.

It seems natural to define UI structure at the granularity of Composites. This will make it easy to define either entire applications declaratively, as well as simple widgets. It also provides a natural model for composing large structures from small ones, and for refactoring complex UI structures.

Imagine the following use pattern:

1. Designer creates a mock in Photoshop, Dreamweaver, ...

mymock.html
{{{
<html><body>
  <!-- A tree of buttons -->
  <div><div><button>Do something</button>...
</body></html>
}}}

2. Developer and/or designer massages this into a GWT template for a page-like Widget 

App.ui.xml
{{{
<g:HTML xmlns:g='http://code.google.com/webtoolkit/com.google.gwt.user.client.ui'>
  <!-- A tree of buttons -->
  <div><div><button>Do something</button>...
</g:HTML>
}}}

App.java
{{{
class App extends Composite implements EntryPoint, Template {
  public void onModuleLoad() {
   // ...
  }
}
}}}

3. The template XML file can now run in the GWT hosted browser (a few clicks and/or command-line exec)

4. Developer and/or designer identifies Widget-like structures (including Panel-like structures, etc.) and factors them out into other templates

App.ui.xml
{{{
<!-- Note how we add a new namespace for the application's package -->
<app:ButtonTree
  xmlns:g='http://code.google.com/webtoolkit/com.google.gwt.user.client.ui'
  xmlns:app='http://code.google.com/webtoolkit/com.example.myapp.client'
/>
}}}

ButtonTree.ui.xml
{{{
<g:Tree xmlns:g='http://code.google.com/webtoolkit/com.google.gwt.user.client.ui'>
  <g:TreeItem>
    <g:Button>Do something</g:Button>
  </g:TreeItem>
</g:Tree>
}}}

5. Still runnable! 

  * As always with GWT, styling is done with CSS.
  * Designer and/or developer can tweak the template, and refresh the GWT hosted browser to see the working app.
  * As developers add code to widgets identified above, the behavior is incorporated automatically.
  * If either the designer or developer breaks anything (e.g. removing a necessary id attribute), the compiler can catch it and warn appropriately.

6. Goto 3

= Goals and Non-goals =

Goals:
  * Simplicity.
  * Designer-friendly (e.g. works with existing tools such as Dreamweaver).
  * Small & fast generated code.
  * Static type and identifier checking.
  * Design/Implementation round-tripping.
  * No runtime support required.
  * Easy to use with 3rd-party widgets.
  * No changes to widgets required.

Non-Goals:
  * Runtime evaluation (i.e. client-side markup).
  * Mixing code & markup.
  * Generating static HTML.

= A Simple Example =
In this rather contrived example, we define a simple labeled text box using HTML and TextBox widgets embedded in a HorizontalPanel.

EditableTextBox.ui.xml:
{{{
<g:HorizontalPanel xmlns:g='http://code.google.com/webtoolkit/com.google.gwt.user.client.ui'>
  <g:HTML id='label'>This <em>text box</em> is editable:</g:HTML>
  <g:TextBox id='editor'/>
<g:HorizontalPanel>
}}}

EditableTextBox.java:
{{{
public abstract class EditableTextBox extends Composite implements Template {

  public static EditableTextBox create() {
    return (EditableTextBox) GWT.create(EditableTextBox.class);
  }

  public EditableTextBox() {
    getEditor().setText("default text");
  }

  public void setCaption(String captionHTML) {
    getCaption().setHTML(captionHTML);
  }

  public String getValue() {
    return getEditor().getText();
  }

  protected abstract HTML getCaption();
  protected abstract TextBox getEditor();
}
}}}

= A More Complex Example =
Here, we have an example of a composite that would define the outer superstructure of an application.

A couple of important things to notice here:
  * Using the HTMLPanel allows us to build part of the structure using HTML instead of lots of nested panels. This can be very efficient for cases where we don't need to do much of anything to it dynamically.
  * The TabPanel structure shown below gives an example of a panel that requires per-child arguments.
  * The MenuItem shows that not all elements need to refer to full widgets.
  * MainComposite and SettingsComposite are assumed to be other parts of the app, which could themselves be built using the declarative UI system. Doing so should make it easy to refactor your UI as the design evolves.

App.ui.xml:
{{{
<g:HTMLPanel xmlns:g='http://code.google.com/webtoolkit/com.google.gwt.user.client.ui'>
  <div class='banner' style='width:100%'>
    <img src='myLogo.gif'/>
    Welcome to my application. It's really cool.
  </div>

  <g:MenuBar>
    <g:MenuItem caption='file'>
      <g:MenuBar>
        <g:MenuItem caption='open'/ id='openMenu'>
        <g:MenuItem caption='close' id='closeMenu'/>
        <g:MenuItem caption='exit' id='exitMenu'/>
      </g:MenuBar>
    </g:MenuItem>
  </g:MenuBar>

  <div class='app' style='width:100%'>
    <g:TabPanel id='tabs'>
      <g:Tab>
        <g:TabCaption><em>Main</em></g:TabCaption>
        <g:MainComposite id='main'/>
      </g:Tab>
      <g:Tab>
        <g:TabCaption><em>Settings</em></g:TabCaption>
        <g:SettingsComposite id='settings'/>
      </g:Tab>
    </g:TabPanel>
  </div>
</g:HTMLPanel>
}}}

App.java:
{{{
public abstract class App extends Composite implements Template {

  public static App create() {
    return (App) GWT.create(App.class);
  }

  public App() {
    getExitMenu().setCommand(new Command() {
      public void execute() {
        // Exit the app.
      }
    });

    // etc...
  }

  protected abstract MenuItem getOpenMenu();
  protected abstract MenuItem getCloseMenu();
  protected abstract MenuItem getExitMenu();
  protected abstract TabPanel getTabs();
  protected abstract MainComposite getMain();
  protected abstract SettingsComposite getSettings();
}
}}}

= Restrictions and Caveats =
Because it uses a generator, composites defined this way must be created using {{{GWT.create()}}}. This also implies that they must have a no-argument constructor (because you cannot pass parameters to {{{GWT.create()}}}. A simple way to make this a little cleaner is to create a public static create() method, so that the site of instantiation just looks like {{{MyWidget w = MyWidget.create()}}}.

{{{
public static MyWidget create() {
  return (MyWidget)GWT.create(MyWidget.class);
}
}}}

Widgets instantiated *by* a template composite must also have a no-argument constructor, because the code generator doesn't know what arguments to pass to them (This restriction can be worked around with a custom parser; see below).

= Implementation Details =
As shown above, the composite base class implements 'Template', which is simply a tag interface that triggers a generator. The generator will find the associated ui.xml and generate a concrete implementation that constructs the widget hierarchy and implements all of the widget getter methods().

(More to come on how the xml gets parsed, how xml structures are defined for widgets, and so forth)

= Open Questions =
  * It would be nice to generate a Java interface skeleton from an xml file to boostrap the process.
  * I18n (string replacement and the like).
  * ImageBundle support.