#summary GWT UI Binder Use Cases

= Introduction =

This document provides various use cases for the use of the UiBinder, a proposed service to generate Widget and DOM structures from XML markup.

= Background =

There are problems with the declarative ui template binder as it was [DeclarativeUi originally proposed]

  * A template-based UI must be istantiated via GWT.create(), causing an implementation detail to be visible as public api
  * within a template, only widgets with a zero arg constructor can be used
  * ClientBundles cannot be used

In addressing these issues, we have talked about encouraging a proxy style of use (basically, use Composite to wrap whatever widget gets GWT.create()'d), but dislike the extra object creation implied. We also hope for a system that can choose to use innerHTML, cloning, or DOM assembly as makes sense per browser type. These shortcomings could be addressed by a combination of developer discipline (yuck) and perhaps the builder pattern, but we still found ourselves faced with the likelihood of wrapping a generated object.

Emily hit upon the idea of the Configurator (here rechristened UiBinder). Itâ€™s like a factory, but responsible for filling in the fields of a Widget (or other object) that someone else instantiates, rather than instantiating one itself. This seems to offer all the benefits of a builder, with no concerns of extra object creation, and as a nice side effect avoids a lot of boilerplate. This document illustrates its application in various use cases.

{{{
/**
 * Interface implemented by classes that generate DOM and widget
 * structures from ui.xml template files. Put the {@link Template}
 * annotation  on a UiBinder class declaration to point the code
 * generator at the right ui.xml file.
 */
interface UiBinder<T> {

  /**
   * Create a new UI and inject it into the given owner.
   * Elements marked in the template by g:field will be
   * assigned to like named fields or setter methods
   * in owner.
   */
  bindUi(T owner);
}

/**
 * Extends UiBinder to provide separate calls to create the root
 * of the UI, and to bind the UI. This allows fancy implementations
 * to support deferred instantiation.
 *
 * <p>Calling the inherited bindUi(owner) method is the same
 * as calling bindRest(createRoot(), owner);
 */
interface ForkedUiBinder<R, O> extends UiBinder<O> {
  /**
   * Return the root element defined in the template,
   * possibly empty. The type R must match the root
   * element in the ui.xml template file.
   */
  R createRoot();

  /**
   * Given a ui root from a previous call to createRoot(),
   * install it into owner. Elements marked in the
   * template by g:field will be assigned to like named
   * fields or setter methods in owner.(If creation of
   * root's contents were deferred, they will be
   * instantiated now.)
   */
  bindRest(R root, O owner);
}
}}}

= Hello World =

Make a simple generated UI, with a named element, and without widgets.

{{{
<!-- HelloWorld.ui.xml -->

<span xmlns:g='package://com.google.gwt.user.client.ui'>
  Hello, <span g:field="nameSpan"/>.
</span>

public class HelloWorld extends UIObject { // Could extend Widget instead

  @Template("HelloWorld.ui.xml")
  interface MyUiBinder implements UiBinder<HelloWorld> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected SpanElement nameSpan;

  public HelloWorld(String name) {
    // call setElement(), set nameSpan
    uiBinder.installUi(this);
    nameSpan.setInnerText(name);
  }
}

// Use:

SpanElement helloWorld = new HelloWorld("World").getElement();
}}}

= Hello Composite World =

Make a simple widget-based UI

{{{
<!-- HelloWidgetWorld.ui.xml -->

<g:HTMLPanel xmlns:g='package://com.google.gwt.user.client.ui'>
  Hello, <g:ListBox g:field="listBox"/>.
</g:HTMLPanel>

public class HelloWidgetWorld extends Composite {

  @Template("HelloWidgetWorld.ui.xml")
  interface MyUiBinder implements UiBinder<HelloWidgetWorld> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected ListBox listBox;

  public HelloWidgetWorld(String... names) {
    // call initWidget(), set listBox
    uiBinder.bind(this);
    for (String name : names) { listBox.addItem(name); }
  }
}

// Use:

HelloWidgetWorld helloWorld =
  new HelloWidgetWorld("able", "baker", "charlie");
}}}


=Hello Deferred World=

Note that this example uses the same ui.xml file as the first. Templates need have no knowledge of what kind of binder will use them.

{{{
<!-- HelloWorld.ui.xml -->

<span xmlns:g='package://com.google.gwt.user.client.ui'>
  Hello, <span g:field='nameSpan'/>.
</span>

public class Deferral extends Widget {

  @Template("HelloWorld.ui.xml")
  interface MyUiBinder implements ForkedUiBinder<SpanElement, Topical> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected SpanElement nameSpan;

  public Deferral(String name) {
    setElement(uiBinder.createRoot());
  }

  @Override protected onAttach() {
    // set nameSpan
    uiBinder.assembleRest((SpanElement)getElement(), this);
    nameSpan.setInnerText(name);
    super.onAttach();
  }
}

// Use:

Deferral helloDeferral = new Deferral("World");
}}}

=Putting a label on a checkbox (referring to generated ids within a template)=

You want to make your personal variant on the single most common widget, a checkbox with a nice, accessible HTML label element tied to it:

{{{
<!-- LabeledCheckBox.ui.xml -->

<span xmlns:g='package://com.google.gwt.user.client.ui'>
  <input type="checkbox" g:field="myCheckBox">
  <label g:for="myCheckBox" g:field="myLabel"/>
</span>

public class LabeledCheckBox extends Widget {
  @Template("LabeledCheckBox.ui.xml")
  interface MyUiBinder implements UiBinder<LabeledCheckbox> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected InputElement myCheckBox;
  protected LabelElement myLabel;

  public LabeledCheckBox() { uiBinder.bind(this); }
 
  public void setValue(boolean b) { myCheckBox.setChecked(b); }

  public boolean getValue() { return myCheckBox.isChecked(); }

  public void setName(String name) { myLabel.setInnerText(name); }

  public String getName() { return myLabel.getInnerText(); }
}
}}}

The proposal here is that a g: prefix on any attribute other than id fills it with the id generated for a corresponding g:field.

There are type matching issues here. The g:field of a DOM element is a string id, while that for a UIObject is typed. So, this should fail with a type mismatch:

{{{
<some:WidgetOfSomeKind g:field="theWidget"> <label gwt:for="theWidget" />
}}}

=Using ClientBundles with a UiBinder=

{{{
<!-- Resourceful.ui.xml -->
<gwt:HTMLPanel
  xmlns:g="package://com.google.gwt.user.client.ui"
  xmlns:res="with://com.my.app.widgets.Resources">

  <img res:-invoke="widgetyImage.apply">

  <div res:class="widgetyStyle.widgetyBlock">
    <div res:-invoke="style.widgetyLogoSprite.apply"/>
    Level of widgetiness:
    <span res:class="widgetyStyle.widgetyRun" g:field="widgetyText"/>
  </div>
</gwt:HTMLPanel>

public class Resourceful extends Composite {
  @Template("Resourceful.ui.xml")
  interface MyUiBinder implements UiBinder<Resourceful> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected SpanElement widgetyText;

  public Resourceful() {
    uiBinder.bind(this);
  }
}

public interface Resources extends ClientBundle {
  @Resource("com.my.app.resources.WidgetyStyle.css")
  WidgetyStyle widgetyStyle();

  @Resource("com.my.app.resources.Widgety.jpg")
  ImageResource widgetyImage();

  public interface WidgetyStyle extends CssResource {
    String widgetyBlock();
    String widgetyRun();
    Sprite widgetyLogoSprite();
  }
}
}}}

The with: uri type marks an object whose methods can be called to fill in attribute values. If no public api is provided to set the "with" argument (as in this example), it must be instantiable by GWT.create().

Note that the apply(Element) methods of Sprite and ImageResource are set via the "-invoke" attribute. That dash is to avoid colliding with an invoke method on Resources itself (perhaps that's not worth worryin about?). There is strong debate over whether this mechanism is too loose. We are tempted to restrict it to work only with objects that implement an Applicator interface, like Sprite and ImageResource do (or will?). 

{{{
public interface Applicator<T> {
  void apply(T t);
}

<div res:-apply="style.widgetyLogoSprite"/>
}}}

Note also that there is no requirement that a with: class implement the ClientBundle interface.

=Share ClientBundle instances=

Extends Resourceful (from the example above) to allow its bundle to be passed in.

{{{
public class Resourceful extends Composite {
 
  @Template("Resourceful.ui.xml")
  interface MyUiBinder implements UiBinder<Resourceful> {
    MyUiBinder with(Resources resources);
  }
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected SpanElement widgetyText;

  public Resourceful(Resources resources) {
    uiBinder.with(resources).bind(this);
  }
}
}}}

If this were using a ForkedUiBinder, it would look like this:

{{{
public class Resourceful extends Composite {

  @Template("Resourceful.ui.xml")
  interface MyUiBinder implements ForkedUiBinder<HTMLPanel, Resourceful> {
    MyUiBinder with(Resources resources);
  }
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  protected SpanElement widgetyText;

  public Resourceful(Resources resources) {
    initWidget(uiBinder.createRoot());
    uiBinder.with(resources).bindRest(getWidget(), this);
  }
}
}}}

The trick here is to define a with() method on MyUiBinder, corresponding to any with:// url defined in your template that you wish to make public.

But wait, I hear you say. We have a single static instance of MyUiBinder, shared by every call to the Resourceful() constructor. Is it really safe to give it an instance method like with(), and load it up with state that may linger if bindRest() is never called?

Not to worry--the binder instance returned by with() does not need to be the same instance that received the with() call. When made necessary like this, we can return a disposable UiBinder instance to accumulate whatever per-instance state is needed. Slick, eh?

And you've probably noticed that you can use this technique to make any constructor argument available to the template...

=Using a widget that requires constructor args=

You have an existing widget that needs constructor arguments.

{{{
public CricketScores(String... teamNames) {...} 
}}}

You use it in a template.

{{{
<!-- UserDashboard.ui.xml -->
<gwt:HTMLPanel
  xmlns:gwt='package://com.google.gwt.user.client.ui'
  xmlns:my='package://com.my.app.widgets' >

  <my:WeatherReport g:field="weather"/>
  <my:Stocks g:field="stocks"/>
  <my:CricketScores g:field="scores" />
</gwt:HTMLPanel>

public class UserDashboard extends Composite {
  @Template("UserDashboard.ui.xml")
  interface MyUiBinder implements UiBinder<UserDashboard> {}
  private static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);

  public UserDashboard() {
    uiBinder.bind(this);
  }
}
}}}

An error results:

{{{
UserDashboard.ui.xml:7:2 [ERROR] Cannot instantiate CricketScores
without a zero args constructor. You must define a non-private
CricketScores createCricketScores() method on UserDashboard.
}}}

So you define one:

{{{
public class UserDashboard extends Composite {
  @Template("UserDashboard.ui.xml")
  interface MyUiBinder implements UiBinder<UserDashboard> {}

  String[] teamNames;
 
  public UserDashboard(String... teamNames) {
    this.teamNames = teamNames;
    uiBinder.bind(this);
  }

  protected CricketScores createCricketScores() {
    return new CricketSores(teamNames);
  }
}
}}}

or perhaps

{{{
public class UserDashboard extends Composite {
  @Template("UserDashboard.ui.xml")
  interface MyUiBinder implements UiBinder<UserDashboard> {}

  CricketScores scores;
 
  public UserDashboard(CricketScores scores) {
    this.scores = scores;
    uiBinder.bind(this);
  }

  protected CricketScores createCricketScores() {
    return scores;
  }
}
}}}