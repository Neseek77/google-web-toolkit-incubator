= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed event handler system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event.
    * Why: Because modifying an interface is a breaking change.
    * Example: We could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * Why: Because modifying an interface is still a breaking change.
    * Example: `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * Example: Most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * Why: Because many event listeners bundle several event methods in a single listener interface.
    * Example: To listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many empty event methods or need to extend from Adapter classes. 
    * Why: Users only usually care about a subset of  listener methods defined in the interface.
    * Example: to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. Therefore, no individual listener method can ever be inlined away.
   * Example:
{{{
  if(clickListeners == null) {
    sinkEvents(Event.ON_CLICK);
    clickListeners = new ClickListenerCollection(); 
  }
  clickListeners.add(handler);
}}} 
  # All event senders must be widgets.
    * Why: because interface sender is defined as a `Widget`.
  # All widget creators must sink their own events.
  

= Proposed Handler System =
== Widget event API == 
This it the API that will be used by all GWT users. It allows users to add new handlers to widgets.

=== Class overview ===
  * `AbstractEvent`
   * Base class for all events
   * New Event classes  
    * `ClickEvent`
    * `KeyDownEvent`
    * ...
  * `HandlerRegistration`
   *  Bookkeeping class to allow handlers to be removed from widgets. Each time a handler is added to a widget, a `HandlerRegistration` instance is returned
  * `EventHandler`
   * Base interface for all handlers
   * New handler interfaces
    * `ClickHandler`
     * `onClick(ClickEvent event)`
    * `KeyDownHandler`
     * `onKeyDown(KeyDownEvent event)`
    * ...
  * For each event we also need to know who fired it
   * `FiresClickEvents`
    * `HandlerRegistation addClickHandler(ClickEvent event)`
   * `FiresKeyDownEvents`
    * `HandlerRegistration addKeyDownHandler(KeyDownEvent event)`
   * ...
=== How it works ===
  * Each handler has a single method with a single argument, such as `onClick(ClickEvent event)` or `onKeyDown(KeyDownEvent event)`.
  * Each widget supporting an event type has a method to add a handler of the form `HandlerRegistration addClickHandler(ClickHandler handler)`.
  * To remove a handler, you must save the `HandlerRegistration` instance returned from the handler's add method and call `removeHandler()` on it.

=== Sample use of a handler ==
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           Window.alert("I have to be right");
        }
      }
    });
}}}

== Widget Developer Event API ==
This is the API that will be used by most widget creators who are creating and packaging their own widgets.  It allows widgets to hook up new handlers and send events to them.

=== Class overview ===
  
  * `EventHook`
   * Event hook is used to allow the widget to hook a handler to a specific event type.
   * For each event type, we have a specific hook, such as 
     * `ClickEvent.HOOK`
     * `KeyDownEvent.HOOK`
     * ...
=== Protected methods ===
  * In `Widget` 
    * `protected finalHandlerRegistration addEventHandler(EventHook hook, EventHandler handler)`
    * `protected final void fireEvent(AbstractEvent event)`


=== How it works ===
  * When a handler is added to a widget, the widget calls `addEventHandler` with the event's hook and the supplied handler.
{{{
 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
}}}
  * To use the widget's handlers, the widget must create an event object, then call `Widget`'s `fireEvent` method on that event object.
{{{
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
}}}


=== Sample widget event handling code ===
This code shows how to wire a `DateBox` to be able to handler a `KeyDownHandler`. In specific, implements the functionality described in the first example.

{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 // implements FiresKeyDownEvents.addKeyDownHandler
 public void addKeyDownHandler(KeyDownHandler handler) {
    // Widget's addEventHandler method. Registers the current handler as a KeyDownEvent handler.
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      // Widget's fireEvent method. It will call each handler registered to KeyDownEvent.
      fireEvent(new KeyDownEvent(e)); 
  }
}
}}}

== Advanced widget creation ==
This API is for those widget creators who need to create custom events and for those creating widgets that do not extend `Widget`

=== Class Overview ===
  * `HandlerManager`
   * Manages all event handlers for widgets. `Widget` lazily creates a `HandlerManager` instance when `addEventHandler` is called.
   * Each `HandlerManager` is associated with a single widget. That widget is set as the source for all events passed into the handler.

=== Protected methods ===
 * `EventHook`
  * `void hookEvent(HandlerManager manager, EventHandler handler)`
   * Setup method that is called when an event handler is added to a widget. Allows the handler system to take care of sinking events when appropriate. For example, `KeyDownEvent`'s event hook checks to see if the sender implements `sinkEvents`, and if it does, sinks `Event.ON_KEY_DOWN`. 
 * `AbstractEvent`
  * `protected abstract void fire(EventHandler handler)`
   * Allows event instance to call correct handler method. For example 
{{{
public class KeyDownEvent extends KeyEvent {
  public void fire(EventHandler handler) {
     ((KeyDownHandler)handler).onKeyDown(this);
  }
 ...
}
}}}
  * `abstract EventHook getEventHook()`
   * Allows event instances to specify the static event hook. For example
{{{
public class KeyDownEvent extends KeyEvent {
  public static final EventHook HOOK = ...
  public EventHook getEventHook(){
    return HOOK;
  }
}
}}}


=== Steps to create a custom event ===
This is an event that is triggered when the user becomes happy. Will be implemented in webkit 10.

  # Define a new event class.  You can add arbitrary metadata in the event class. For simplicity, we will not include any here though.
{{{
public class HappyEvent extends AbstractEvent{
   ...
}
}}}
  # Define a new handler and fires class for the event class.
{{{
interface HappyHandler extends EventHandler {
  public void onHappiness(HappyEvent event);
}

interface FiresHappyEvents {
  public HandlerRegistration addHappyHandler(HappyHandler handler);
}
}}}
  # Wire up the `HappyEvent.fire` method
{{{
class HappyEvent extends MoodEvent {
  protected void fire(EventHandler handler) {
    ((HappyHandler)handler).onHappiness(this);
  }
  ...
}
}}}
  # Add a unique event hook
{{{
class HappinessEvent extends MoodEvent {
  public static EventHook HOOK = new EventHook();
 
  public EventHook getEventHook(){
    return HOOK; 
  }
  ...
}
}}}
  # Wire up `EventHook.hookEvent` if necessary
{{{

class HappyEvent extends MoodEvent {
  public static final HookEvent HOOK = new HOOK(){
  public void hookEvent(EventManager eventManager, EventHandler handler) {
    // Sanity checks
    Object sender = eventManager.getEventSource();
    assert(handler instanceof HappyHandler);
    assert(sender instanceof FiresHappyEvents);

    if(eventManager.isFirstHandler(handler){
      // If source implements sink events, sink it. 
      // No, ON_HAPPY doesn't exist, just run with it...
      BrowserEvent.trySinkEvents(source, Event.ON_HAPPY);
    }
  }
  ...
}}}

=== Full code needed to create a `Happy` handler === 

{{{
public interface HappyHandler extends EventHandler {
  public void onHappy(HappyEvent event);
}

public interface FiresHappyEvents {
  public HandlerRegistration addHappyHandler(HappyHandler handler);
}

public class HappyEvent extends KeyEvent {
  public static EventHook HOOK = new EventHook(){
    public void hookEvent(EventManager eventManager, EventHandler handler) {
      // Sanity checks
      Object sender = eventManager.getEventSource();
      assert(handler instanceof HappyHandler);
      assert(sender instanceof FiresHappyEvents);

      if(eventManager.isFirstHandler(handler){
        BrowserEvent.trySinkEvents(source, Event.ON_HAPPY);
      }
     }
  };
  public EventHook getEventHook(){
    return HOOK; 
  }

  public void fire(EventHandler handler) {
    ((HappyHandler)handler).onHappy(this);
  }
   
}


}}}
== Class Diagram ==
  * Widget API classes are in blue
  * Widget developer classes are in green
  * Advanced widget developer classes are in black

http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg
 
== How it actually works ==
 * Adding event handler *myHandler* as a handler for `MyEvent`
   # In `Widget`
    * ensure `HandlerManager` *handlerManager* instance exists
    * call `handlerManager.addEventHandler(MyEvent.HOOK, myHandler)`
   # In `HandlerManager`  
    * store *myHandler* in a map indexed by event hook
    * call `EventHook.hookEvent` for event specific setup
 * Firing a `MyEvent` event
   # In 'Widget'
    * create new `MyEvent` *myEvent* instance
    * call `handlerManager.fireEvent(myEvent)`
   # In `HandlerManager`
    * set the correct sender field in *myEvent*
    * get the correct event hook from *myEvent*, in specific `MyEvent.HOOK`
    * retrieve the list of handlers associated with `MyEvent.HOOK`
    * call  `myEvent.fireEvent(handler)` on each handler in the list. 
   # In `MyEvent`
    * cast the current handler as a `MyEventHandler`
    * call correct handler method on the current handler, passing in the current event.
 

 
== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single manager field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed. Remaining boiler plate code will be inlined ||
|| (7) All event senders must be widgets || Senders simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||