= Introduction =

The current listener widget event system is very easy to use and understand, which are significant advantages. However, it has certain disadvantages as well, therefore in this document we:
  * Detail the disadvantages of the current listeners system.
  * Explain the proposed event handler system.
  * Revisit the disadvantages of the current listener system and show how the handler system addresses each one. 



= Disadvantages of current listener system =
  # We cannot add extra information about an event
    * Why: Because modifying an interface is a breaking change.
    * Example: We could not add native events to the current `Click` or `Change` listeners.
  # We cannot add a new feature to a current listener. 
    * Why: Because modifying an interface is still a breaking change.
    * Example: `TreeListener` cannot be expanded to allow more tree events.
  # Many widgets do not have any listeners, and yet have three or four listeners fields that need to be null initialized. 
    * Example: Most `Label` widgets have no events, yet have three fields that need to be null initialized.
  # We have to sink unnecessary events on widgets. 
    * Why: Because a widget cannot know what handler methods the user requires
    * Example: To listen to a mouse down event, mouse move events are also sunk. 
  # Our users end up with many empty event methods or need to extend from Adapter classes. 
    * Why: Users only usually care about a subset of  listener methods defined in the interface.
    * Example: to add a mouse up listener, you end up with empty mouse down and mouse move methods as well.
  # We repeat the same lines of boiler plate code in many different widgets to check if the listeners are instantiated and instantiate them. 
   * Example:
{{{
    if(clickListeners == null) {
      sinkEvents(Event.ON_CLICK);
      clickListeners = new ClickListenerCollection(); 
    }
    clickListeners.add(handler);
}}} 
  # All event senders must be widgets.
    * Why: because interface sender is defined as a `Widget`.
  # All widget creators must sink their own events.
  

= Proposed Handler System =
== API exposed by widgets == 
This it the API that will be used by all GWT widget users. 

=== Class overview ===
  * Classes
    * `AbstractEvent`
      * Base class for all events
      * New Event classes  
        * `ClickEvent`
        * `KeyDownEvent`
        * ...
    * `HandlerRegistration`
      *  Bookkeeping class to allow handlers to be removed from widgets.
  * Interfaces
    * `EventHandler`
      * Base interface for all handlers
      * New handler interfaces
        * `ClickHandler`
        * `KeyDownHandler`
        * ...
    * For each handler, we also have a source
      * `FiresClickEvents`
      * `FiresKeyDownEvents`
      * ...
  * Functionality
    * Each handler has a single method with a single argument, such as `onClick(ClickEvent event)` or `onKeyDown(KeyDownEvent event)`
    * Each widget supporting an event type has a method to add a handler of the form `HandlerRegistration addClickHandler(ClickHandler handler)
    * To remove a handler, you must save the handler registration and call `registration.removeHandler()`

== Widget Developer API ==
This is the API that will be used by widget creators who are creating and packaging their own widgets.

=== Class overview ===
  * Classes
    * `EventHook`
      * Event hook is used to allow the widget to hook a handler to a specific event.
      * For each event type, we have a specific hook, such as `ClickEvent.HOOK`, `KeyDownEvent.Hook`

  * Widget enhancements
    * `HandlerRegistration addEventHandler(EventHook hook, EventHandler handler)`
    * `void fireEvent(AbstractEvent event)`


=== Sample use of a handler ==
{{{
 DateBox start = new DateBox();
 start.addKeyDownHandler(new KeyDownHandler() {
      public void onKeyDown(KeyDownEvent e) {
        if (e.getKeyCode() == KEY_RIGHT){
           ... 
        }
      }
    });
}}}


 
===

== Class Diagram ==
http://google-web-toolkit-incubator.googlecode.com/svn/trunk/doc/wiki-support/images/HandlerDesign.jpg
 



=== Sample widget implementation of a handler==
To implement a handler, you must be able to use the classes in *green* above.

{{{
public class DateBox extends Composite implements FiresKeyDownEvents {
...

 public void addKeyDownHandler(KeyDownHandler handler) {
    addEventHandler(KeyDownEvent.HOOK, handler);
 }
  @Override
  public void onBrowserEvent(Event e){
    ...
    case ON_KEYDOWN:
      fireEvent(new KeyDownEvent(e)); 
  }
  }}}

===  Sample declaration of a new handler interface ===
{{{
interface KeyDownHandler extends EventHandler {
  public void onKeyDown(KeyDownEvent event);
} 
}}}

=== Sample declaration of an event ===
{{{
class KeyDownEvent extends KeyEvent {
 public static Hook HOOK = new Hook(){
    public void hookEvent(HandlerRegistration registration) {
      // Sanity checks
      assert(registration.getHandler() instanceof KeyDownHandler);
      assert(registration.getSource() instanceof FiresKeyDownEvents);

      if(registration.isFirstHandlerForEvent()){
        // If source implements sink events, sink ON_KEYDOWN
        BrowserEvent.trySinkEvents(source, Event.ON_KEYDOWN);
      }
    }
  }

  public HandlerHook getEventHook() {
    return HOOK;
  }
  
  public void fire(EventHandler handler) {
    ((KeyDownHandler)handler).onKeyDown(this));
  }
}
}}}

== How the handler system solves problems ==

||Listener Problem || Handler solution ||
||(1) Cannot add extra information about an event. || Can add metadata to event ||
||(2) Cannot add extra features || Each handler represents a single method, so more can always be added || 
||(3) Excess unused listener fields || A single handlers field is used ||
||(4) Excess events are sunk || Only the events that are needed are sunk ||
||(5) Extra blank methods || No extra methods needed ||
||(6) Boiler plate code || Between `Widget` enhancements and `HandlerManager` classes, most boiler plate code removed ||
|| (7) All event senders must be widgets || Senders simply must implement the `Fires*` interface ||
|| (8) All widgets must manage sinking of events || All standard widgets have events sunk automatically ||